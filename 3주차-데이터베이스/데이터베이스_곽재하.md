# 인덱스에 대해 설명해주세요.
인덱스는 검색 성능의 속도를 높여주는 자료구조입니다.
보통 DBMS에 데이터를 저장하면 ArrayList 형태로 저장하는데, 인덱스를 사용하면 데이터와 데이터 주소값이 키-값으로 저장됩니다.
일반적으로 select문을 실행시 server process 가 구문분석과정을 마친 후 database buffer cache 에 조건에 부합하는 데이터가 있는지 확인합니다.
만약 해당 정보가 없다면 디스크 파일에서 조건에 부합하는 블럭을 찾아 database buffer cache 에 가져온 뒤 사용자에게 보여주는데 이 과정에서 인덱스가 없다면 전부 database buffer cache 로 복사한 뒤 풀스캔으로 찾게 됩니다.
하지만 인덱스가 있다면 where절의 조건의 컬럼이 index의 키로 생성되어있는지 확인한 뒤 인덱스에 먼저가서 조건에 부합하는 정보가 어떤 rowid 를 가지고 있는지 확인한 후 rowid에 있는 블럭을 찾아가 해당 블럭만 buffer cache 에 복사합니다.

# 데이터베이스에서 인덱스를 사용하는 이유 및 장단점에 대해 설명해주세요.
데이터베이스에서 인덱스를 사용하는 이유는 검색성능을 향상시키기 위함입니다.
하지만 검색성능을 실질적으로 향상시키기 위해서는 해당 쿼리가 index를 사용하는지, 카디널리티, Selectivity 같은 요소들이 고려된 인덱스가 생성되어야 합니다.
일반적인 경우의 장점으로는 빠른 검색 성능을 들 수 있습니다.
일반적인 경우의 단점으로는 인덱스를 구성하는 비용 즉, 추가, 수정, 삭제 연산시에 인덱스를 형성하기 위한 추가적인 연산이 수행됩니다.
따라서, 인덱스를 생성할 때에는 트레이드 오프 관계에 놓여있는 요소들을 종합적으로 고려하여 생성해야합니다.

# 트랜잭션에 대해서 설명해주세요.
트랜잭션이란 데이터베이스의 상태를 변화시키는 하나의 논리적인 작업 단위라고 할 수 있으며, 트랜잭션에는 여러개의 연산이 수행될 수 있습니다.
트랜잭션은 수행중에 한 작업이라도 실패하면 전부 실패하고, 모두 성공해야 성공이라고 할 수 있습니다.

더이상 분할이 불가능한 업무처리의 단위 또는 읽기와 쓰기를 하나의 논리적 단위로 묶는 방법으로 퀴리를 하나의 묶음으로 하여 수행하는 도중 중단되었다면 처음부터 다시 실행하는 Rollback을 수행하고, 오류 없이 실행을 마칠 경우 commit 하는 실행 단위를 의미합니다.

# ACID에 대해서 설명해주세요.
ACID는 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질입니다.

**Atomicity(원자성)**: 트랜잭션의 연산은 모든 연산이 완벽히 수행되어야 하며, 한 연산이라도 실패하면 트랜잭션은 실패해야 합니다. 트랜잭션의 작업이 부분적으로 실행되거나 중단되지 않는 것을 보장하는 것입니다. <br>
**Consistency(일관성)**: 트랜잭션은 유효한 상태로만 변경될 수 있습니다. 트랜잭션의 작업 처리 결과가 항상 일관성이 있다는 것을 뜻합니다. 데이터 타입이 정수형인데, 저장 후에 문자열이 되면 일관성을 위배한 것입니다. 트랜잭션이 진행되는 동안 데이터베이스가 변경되더라도 처음에 트랜잭션을 진행하기 위해 참조된 데이터베이스로 진행되는 것을 뜻합니다. <br>
**Isolation(고립성)**: 트랜잭션은 동시에 실행될 경우 다른 트랜잭션에 의해 영향을 받지 않고 독립적으로 실행되어야 합니다. 트랜잭션 수행시 다른 트랜잭션의 작업이 끼어들지 못하도록 보장하는 것을 말합니다. <br>
**Durability(내구성 or 지속성)**: 트랜잭션이 커밋된 이후에는 시스템 오류가 발생하더라도 커밋된 상태로 유지되는 것을 보장해야 합니다. (일반적으로 비휘발성 메모리에 데이터가 저장되는 것을 의미) 성공적으로 수행된 트랜잭션이 영구적으로 반영되는 것을 뜻합니다. <br>

#트랜잭션 격리 수준(Transaction Isolation Levels)에 대해서 설명해주세요.
트랜잭션 격리수준은 고립도와 성능의 트레이드 오프를 조절합니다.

**READ UNCOMMITTED**: 다른 트랜잭션에서 커밋되지 않은 내용도 참조할 수 있다. <br>
**READ COMMITTED**: 다른 트랜잭션에서 커밋된 내용만 참조할 수 있다. <br>
**REPEATABLE READ**: 트랜잭션에 진입하기 이전에 커밋된 내용만 참조할 수 있다. <br>
**SERIALIZABLE**: 트랜잭션에 진입하면 락을 걸어 다른 트랜잭션이 접근하지 못하게 한다.(성능 매우 떨어짐) <br>


# 정규화란 무엇이고 장점과 단점은 무엇이 있을까요?
정규화는 데이터의 중복방지, 무결성을 충족시키기 위해 데이터베이스를 설계하는 것을 의미합니다.

정규화는 데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 방법이며 데이터를 분해하는 과정입니다. 
관계형데이터베이스의 설계에서 테이블 간에 중복되는 데이터가 발생하지 않도록 릴레이션을 분해하여 구조화하는 프로세스를 말합니다.
정규화의 장점으로는 불필요한 데이터를 제거하고 데이터의 중복을 최소화하여 디스크 저장공간을 훨씬 효율적으로 사용할 수 있다는 점입니다.
만약 한 테이블에 모든 정보를 다 넣게되면 불필요하게 중복되는 데이터가 저장될 수 있고, 더 많은 디스크 공간을 차지하게 됩니다. 하지만 정규화를 통해 pk와 fk로 연결하여 사용하면 디스크 공간을 효율적으로 사용할 수 있습니다. 또한, 이상현상을 방지할 수 있습니다.
단점으로는 join 연산이 증가되는 쿼리가 발생시 응답시간이 저하될 수도 있습니다.
**장점** <br>
데이터의 일관성, 최소한의 중복, 최대한의 데이터 유연성을 위한 방법 -> 데이터를 분해하는 과정. 만약 하나의 테이블에 모든 정보를 다 넣게되면 불필요하게 중복되는 데이터가 저장될 수 있고, 더 많은 디스크 공간을 차지. 따라서 테이블 간 PK(기본키)와 FK(외래키)로 연결해서 사용하면 디스크 공간을 훨씬 효율적으로 사용할 수 있음.
불필요한 데이터를 제거 -> 논리적으로 저장
데이터베이스 변경 시 이상현상 제거
효과적인 검색 알고리즘 생성
**단점** <br>
Join연산의 증가로 응답 시간이 저하

# RDBMS vs NOSQL에 대해서 설명해주세요.
RDBMS는 데이터베이스를 이루는 객체들의 릴레이션을 통해서 데이터를 저장하는 데이터베이스입니다. SQL을 사용해 데이터의 저장, 질의, 수정, 삭제를 할 수 있으며 데이터를 효율적으로 보관하는 것을 목적으로 하고 구조화가 굉장히 중요합니다.
장점으로는 명확한 데이터 구조를 보장하고, 중복을 피할 수 있습니다.
NOSQL은 RDBMS에 비해 자유로운 형태로 데이터를 저장합니다. 또한 수평확장을 할 수 있고 분산처리를 지원합니다. 다양한 형태의 NOSQL 데이터베이스가 있고, 대표적으로 key-value store, bigtable, dynamo, document db, graph db 등이 있습니다.
둘은 대체될 수 있는 것이 아니고, 각각 필요한 시점에 적절히 선택해서 사용해야 합니다. 둘 다 같이쓰는 상호보완적인 존재가 될 수도 있습니다.

#Redis에 대해서 간단히 설명해주세요.
Redis는 key-value store NOSQL DB입니다. 싱글스레드로 동작하며 자료구조를 지원합니다. 그리고 다양한 용도로 사용될 수 있도록 다양한 기능을 지원합니다. 데이터의 스냅샷 혹은 AOF 로그를 통해 복구가 가능해서 어느정도 영속성도 보장됩니다.
스프링에서는 세션을 관리하거나, 캐싱을 하는데에 자주 사용되는 것으로 알고 있습니다.

# Redis와 Memcached의 차이에 대해서 설명해주세요.
Redis는 싱글 스레드 기반으로 동작하고, Memcached는 멀티스레드를 지원해서 멀티 프로세싱이 가능합니다.
Redis는 다양한 자료구조를 지원하고, Memcached는 문자열 형태로만 저장합니다.
Redis는 여러 용도로 사용할 수 있도록 다양한 기능을 지원합니다.
Redis는 스냅샷, AOF 로그를 통해서 데이터 복구가 가능합니다.

# Elastic Search에 대해서 간단히 설명해주세요.
Elastic Search는 자바로 개발된 오픈소스 검색엔진 입니다. 보통 단독으로 사용하기보다는 ELK 스택이라고 부르는 Logstash, Kibana, Beats를 추가적으로 사용합니다.
Inverted Index 구조로 데이터를 저장해서, 전문(Full-text) 검색시에 RDBMS에 비해 뛰어난 성능을 보장합니다.
다양한 용도로 사용할 수 있습니다. (데이터 저장, 문서 검색, 위치 검색, 머신 러닝 기반 검색, 로그 분석, 보안 감사 분석 등)

# Elastic Search의 인덱스구조와 RDBMS의 인덱스 구조의 차이에 대해 설명해주세요.
Elastic Search는 Inverted-Index 구조로 데이터를 저장합니다. 이는 책의 색인을 생각해보면 쉬운데, 특정 단어가 출현하는 doc을 저장하는 것입니다. 반면 RDBMS는 B-Tree와 그와 유사한 인덱스를 사용합니다. 데이터가 어디에 존재하는지 어떤 순서로 저장하는 지의 차이라고 생각합니다. RDBMS에도 다양한 인덱스 구조가 있으나 여기서 예로 든 것은 B-Tree 인덱스입니다.

# Elastic Search의 키워드 검색과 RDBMS의 LIKE 검색의 차이에 대해 설명해주세요.
Elastic Search의 키워드 검색은 document를 저장할 때 수행하는 알고리즘과 동일한 알고리즘으로 키워드를 분리합니다. 그 중에서 랭킹알고리즘을 통해서 가장 유사한 순서대로 결과를 나타냅니다.
RDBMS에서의 LIKE 검색은 와일드카드로 시작하지 않는 경우에만 인덱스를 사용하고 나머지 경우는 전체를 탐색하기 때문에 상대적으로 느립니다.

# MongoDB에 대해서 간단히 설명해주세요.

요즘 시대에는 구글이나 페이스북과 같은 글로벌 서비스를 제공하는 회사가 늘어나면서 방대한 양의 데이터를 충분히 빠른 속도로 처리할 수 있는 데이터베이스에 대한 필요성이 대두되기 시작했습니다. 이런 대용량 데이터 서비스에서는 기존의 RDBMS 로 처리하기는 효율적이지 못할 수 있습니다 (비용적인 문제, 데이터를 분산하기 위해 수십,수백대의 서버로 분산시켜야 함). MySQL 같이 오픈 소스 RDBMS는 비용적인 문제를 해결해주기는 하였지만 이러한 MySQL도 빅데이터를 처리하기에는 문제가 있습니다. 데이터 양이 많고, 매번 데이터베이스 스키마에 맞게 데이터를 조작하여 작업을 해야한다면 비효율적일 수 있습니다.
 
여느 NoSQL과 같이 MongoDB는 이러한 데이터를 다루는데 적합한 데이터베이스입니다. 솔루션 자체적으로 분산 처리, 샤딩, 데이터 리밸런싱, 데이터 복제, 복구 등을 지원하고 무엇보다 Schema-Free(Schema-less)한 구조이기에 대용량의 데이터 작업에 아주 효율적인 데이터베이스라고 볼 수 있습니다. 또한 일부 RDBMS의 기능을 제공하기도 합니다 (인덱싱 등, 내부적으로 B-Tree 자료구조를 이용하여 인덱스를 관리).

공식 홈페이지에 나와있는 MongoDB의 소개
 
MongoDB 는 유연하고 JSON과 유사한 문서에 데이터를 저장합니다. 즉, 필드는 문서마다 다를 수 있으며 시간에 따라 데이터 구조를 변경할 수 있습니다.
문서 모델 은 응용 프로그램 코드의 객체에 매핑 되므로 데이터를 쉽게 사용할 수 있습니다.
임시 쿼리, 인덱싱 및 실시간 집계 는 데이터에 액세스하고 분석하는 강력한 방법을 제공합니다
MongoDB는 기본적 으로 분산 데이터베이스 이므로 고 가용성, 수평 확장 및 지리적 분포가 내장되어 있고 사용하기 쉽습니다.
MongoDB는 무료로 사용할 수 있습니다 .

# CAP 이론과, Eventual Consistency에 대해서 설명해주세요.
CAP 이론은 분산 환경에서 모두를 만족하는 시스템은 없다는 이론입니다.

**Consitenty(일관성)**: ACID의 일관성과는 약간 다릅니다. 모든 노드가 같은 시간에 같은 데이터를 보여줘야 한다는 것입니다. <br>
**Availability(가용성)**: 모든 동작에 대한 응답이 리턴되어야 합니다. <br>
**Partition Tolerance(분할 내성)**: 시스템 일부가 네트워크에서 연결이 끊기더라도 동작해야 합니다. <br>

CAP는 해당 시스템이 이거다 하고 말하기 곤란한게 어떻게 클러스터링 하느냐에 따라 달라질 수 있습니다. 그렇기 때문에 어떤 전략을 취할 때 어떤 것을 선택했는가를 잘 알아야 합니다. (단순히 MySQL이 CA입니다. 보다는 어떤 이유로 CA인지 근거를 생각해보기) 그리고 어느정도 한계가 있는 이론이고 PACELC 이론이라고 또 있습니다.
Eventual Consistency는 이 Consistency를 보장해주지 못하기 때문에 나온 개념으로, Consistency를 완전히 보장하지는 않지만, 결과적으로 언젠가는 Conssistency가 보장됨을 의미합니다.

