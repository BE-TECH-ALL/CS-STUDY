## SQL이란?
SQL(Structured Query Language)은 데이터베이스 관리 시스템(DBMS)에서 데이터를 조작, 검색, 삽입, 수정, 삭제하는 데 사용되는 표준화된 프로그래밍 언어이다.
여기서 쿼리(Query)란 데이터베이스에서 데이터를 검색하거나 조작하는 명령문을 말한다.

## 트랜잭션에 대해서 설명해주세요.
트랜잭션(Transaction)은 데이터베이스(Database)에서 수행되는 하나의 논리적인 작업 단위를 의미한다.

## 트랜잭션 격리 수준(Transaction Isolation Levels)에 대해서 설명해주세요.
READ UNCOMMITTED: 다른 트랜잭션이 아직 커밋되지 않은 데이터를 읽을 수 있다. 따라서 이 수준은 데이터 일관성을 보장하지 않으며, 예기치 않은 결과가 발생할 수 있다.

READ COMMITTED: 어떤 트랜잭션의 변경 내용이 COMMIT 되어야만 다른 트랜잭션에서 조회할 수 있다. 오라클 DBMS에서 기본으로 사용하고 있고, 온라인 서비스에서 가장 많이 선택되는 격리수준이다. 언뜻보면 데이터 일관성 문제가 해결되는 것 같지만, A 트랜잭션이 10회 조회하는 중간에 B 트랜잭션이 수정하고 커밋하면 A 트랜잭션이 다른 결과를 조회하게 된다.

REPEATABLE READ: 트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회할 수 있는 격리수준이다. MySQL DBMS에서 기본으로 사용하고 있다. 이 격리수준에서는 아까의 A,B 트랜잭션과 같은 상황이 벌어지는 경우 A 트랜잭션이 UNDO 영역에 백업된 내용을 가지고 수정되지 않은 처음 조회하던 내용 그대로 조회한다. 하지만 이 격리 수준에서도 팬텀 리드와 같은 문제가 발생할 수 있다.

SERIALIZABLE: 모든 트랜잭션을 순차적으로 처리하도록 보장한다. 이 수준은 데이터 일관성을 보장하지만, 동시성 처리에 대한 성능 저하가 발생할 수 있다. 

## RDBMS vs NOSQL에 대해서 설명해주세요.
RDBMS(Relational Database Management System)은 관계형 DB를 의미하고, NoSQL(Not only SQL)은 비관계형 DB를 의미한다.
RDBMS는 데이터의 구조가 고정되어 있으며, 데이터의 일관성과 무결성을 보장하기 위한 기능을 제공한다. 또한, ACID(Atomicity, Consistency, Isolation, Durability) 원칙을 따르기 때문에 데이터의 안정성이 높다. RDBMS의 종류로는 Oracle, MySQL, PostgreSQL 등이 있다.

NoSQL은 테이블 형태가 아닌 Key-Value, Document, Graph 등의 형태로 데이터를 구성한다. NoSQL은 데이터의 유연성과 확장성을 보장하기 위해 고안된 시스템으로, 데이터의 구조가 동적으로 변할 수 있다. 또한, 대용량의 분산 데이터베이스 시스템에서 빠른 속도로 데이터를 처리할 수 있다. NoSQL의 종류로는 MongoDB, Cassandra, Redis 등이 있다.

## Elastic Search에 대해서 간단히 설명해주세요.
Elasticsearch는 검색 및 분석을 위한 오픈소스 분산 검색 엔진으로, Lucene 검색 라이브러리를 기반으로 하며 JSON 문서를 저장하고 검색하는 데 특화되어 있다.

## Elastic Search의 인덱스구조와 RDBMS의 인덱스 구조의 차이에 대해 설명해주세요.
저장 방식: Elasticsearch는 Inverted-Index 구조를 사용하여 데이터를 저장한다. 반면에, RDBMS는 B-Tree 구조를 사용하여 데이터를 저장한다.
(Inverted-Index 구조 : 흔히 생각하는 value에 해당하는 단어가 key로 저장되고, id를 value에 저장하는 구조)
색인 방식: Elasticsearch는 실시간 색인 방식을 사용하여 새로운 데이터를 색인화(Indexing)한다. RDBMS는 배치 색인 방식을 사용하여 일정 주기마다 데이터를 색인화한다.

데이터 타입: Elasticsearch는 다양한 데이터 타입을 지원하며, 검색 엔진으로써 텍스트와 같은 비정형 데이터에 특화되어 있다. RDBMS는 주로 정형 데이터를 다루는데 특화되어 있다.

확장성: Elasticsearch는 분산환경에서 데이터를 처리하며, 수평 확장이 용이하다. RDBMS는 수직 확장 방식을 사용하여 성능을 향상시키는데 한계가 있다.

검색 기능: Elasticsearch는 다양한 검색 기능을 제공하며, 텍스트 검색 및 분석에 특화되어 있다. RDBMS는 주로 정렬, 그룹화 및 집계와 같은 기본적인 검색 기능을 제공한다.

## Elastic Search의 키워드 검색과 RDBMS의 LIKE 검색의 차이에 대해 설명해주세요.
검색 속도: Elasticsearch의 키워드 검색은 Inverted-Index 구조를 사용하여 검색 속도가 매우 빠르다. RDBMS의 LIKE 검색은 테이블 전체를 순차적으로 검색해야 하므로 검색 속도가 상대적으로 느리다.

검색 정확성: Elasticsearch의 키워드 검색은 텍스트 분석과 검색 기능이 뛰어나며, 검색 결과의 정확성이 높다. RDBMS의 LIKE 검색은 와일드카드 문자를 사용하여 검색하는 경우, 검색 결과의 정확성이 떨어질 수 있다. (ex : abc 검색시 abcd, abce 등등 다른 것도 전부 검색된다. ES에서는 should를 사용해서 보다 정확한 검색 결과를 먼저 나타낼 수 있다.)

검색 범위: Elasticsearch의 키워드 검색은 전문 텍스트, 즉 문서의 모든 필드에 대해서 검색이 가능하다. RDBMS의 LIKE 검색은 특정 컬럼에 대해서만 검색이 가능하다.

다양한 검색 기능: Elasticsearch는 다양한 검색 기능을 제공하며, 검색 결과를 스코어링하여 정확도를 높일 수 있다. RDBMS는 LIKE 검색 이외에도 여러 가지 검색 기능을 제공하지만, 검색 기능이 상대적으로 제한적이다.

## 인덱스란 무엇인가요?
인덱스(Index)는 데이터베이스에서 데이터를 빠르게 검색하거나 정렬하기 위해 사용되는 자료 구조이다. 인덱스는 데이터베이스 테이블 내의 열(column)에 대한 키(key)와 해당 키가 위치한 레코드의 주소로 구성된다. 인덱스는 데이터 검색 시 데이터베이스 엔진이 전체 테이블을 스캔하지 않고, 인덱스를 참조하여 검색 속도를 높이는 역할을 한다.
일반적으로 B-트리(B-Tree)나 해시(Hash) 테이블과 같은 자료 구조로 이루어져 있다.

## 데이터베이스에서 인덱스를 사용하는 이유 및 장단점에 대해 설명해주세요.
인덱스(Index)는 데이터의 검색 속도를 높이기 위한 기술 중 하나로, 특정 컬럼(Column)의 값을 기준으로 데이터를 정렬하고, 검색 시에 이를 참조하여 검색 속도를 빠르게 한다.
인덱스를 사용하는 이유는
1. 검색 속도 향상 - 인덱스를 사용하지 않으면 전체 데이터를 검색해야 하기 때문에 검색 속도가 매우 느려질 수 있다.
2. 데이터베이스 성능 향상 - 검색 속도가 빨라지면 처리 속도도 빨라지므로, 시스템 전체의 성능이 향상된다.

인덱스의 장점으로는
1. 검색 속도가 빠르다.
2. 데이터베이스 성능이 향상된다.
3. 중복 데이터를 줄일 수 있다.

인덱스의 단점으로는
1. 인덱스를 생성하는 데 시간과 리소스가 소요된다.
2. 인덱스를 생성하면 데이터베이스 용량이 더 많이 필요하다.
3. 인덱스를 잘못 사용하면 검색 속도가 느려질 수 있다.

## ACID에 대해서 설명해주세요.
원자성(Atomicity): 하나의 트랜잭션은 전체가 실행되거나 전혀 실행되지 않아야 한다. 트랜잭션의 모든 작업이 성공적으로 수행되어야만 데이터베이스에 반영된다. 만약 트랜잭션 중간에 오류가 발생하면 이전 상태로 롤백된다.

일관성(Consistency): 트랜잭션이 실행되기 전과 실행된 후의 데이터베이스 상태는 일관성이 있어야 한다. 데이터 손상이나 오류 때문에 테이블 무결성에 의도치 않은 결과가 생기지 않아야 한다.

격리성(Isolation): 여러 개의 트랜잭션이 동시에 실행될 때, 각각의 트랜잭션은 서로 영향을 주지 않도록 격리되어야 한다. 즉, 어떤 트랜잭션이 실행 중일 때 다른 트랜잭션이 동일한 데이터를 수정할 수 없다.

지속성(Durability): 트랜잭션이 성공적으로 수행된 후에는 그 결과가 영구적으로 저장되어야 한다. 만약 시스템에 장애가 발생하더라도, 데이터베이스는 이전에 성공적으로 수행된 트랜잭션의 결과를 복원할 수 있어야 한다.

## 정규화에 대해서 설명해주세요.
정규화(Normalization)는 데이터베이스의 설계를 개선하여 중복을 최소화하고 데이터의 일관성과 무결성을 유지하기 위한 과정이다. 
장점으로는
1. 데이터 일관성 보장 - 정규화를 수행하면 데이터를 중복 없이 구조화하므로, 데이터 일관성을 보장할 수 있다.
2. 데이터 중복 최소화 - 정규화를 수행하면 데이터 중복을 최소화하여 저장 공간을 절약할 수 있다.
3. 데이터 검색 속도 향상 - 정규화된 테이블은 인덱스 구성이 용이하므로 데이터 검색 속도가 향상된다.

단점으로는
1. 불필요한 JOIN 연산 - 정규화를 수행하면 데이터를 여러 개의 테이블로 나누어 저장하므로, 데이터를 조회할 때 JOIN 연산이 필요할 수 있다. JOIN 연산은 시스템 자원을 많이 사용하므로, 성능 저하의 원인이 될 수 있다.
2. 복잡한 데이터 구조 - 정규화를 과도하게 수행하면 데이터 구조가 복잡해지므로, 데이터를 조회하거나 수정하는 것이 어려울 수 있다.
3. 데이터 중복 최소화로 인한 성능 저하 - 데이터 중복을 최소화하려면 테이블 간 관계를 맺어야 하므로, 테이블 간 데이터 일관성을 유지하기 위해 추가적인 작업이 필요할 수 있다.

## Redis에 대해서 간단히 설명해주세요.
Redis(Remote Dictionary Server)는 인메모리(In-Memory) 데이터 저장소로, 메모리에 데이터를 저장하므로 빠른 데이터 처리 속도를 제공한다. Redis는 Key-Value 기반 데이터 저장소로서, Key-Value 쌍으로 데이터를 저장하고 검색할 수 있다.
Redis는 문자열(String), 리스트(List), 셋(Set), 정렬된 셋(Sorted Set), 해시(Hash) 등 다양한 데이터 형식을 지원한다.

## Redis와 Memcached의 차이에 대해서 설명해주세요.
데이터 타입: Redis는 다양한 데이터 타입을 지원한다. 문자열, 리스트, 해시, 집합, 정렬된 집합 등 다양한 타입의 데이터를 저장하고 조회할 수 있습니다. Memcached는 문자열 데이터만 저장하고 조회할 수 있다.

지속성: Redis는 디스크에 데이터를 저장할 수 있는 기능을 지원하며, 데이터를 영구적으로 보존할 수 있다. 반면에, Memcached는 메모리에만 데이터를 저장하기 때문에, 서버가 재시작되거나 오류가 발생하는 경우 데이터가 손실될 수 있다.

분산 캐싱: redis는 클러스터링 기능이 있어서, 여러 노드에 샤딩과 복제를(샤딩: 데이터를 분할해서 서로다른 DB에 저장 하는 프로세스, 복제 : 데이터를 여러 노드에 동일한 사본으로 복사하는 프로세스) 지원해서 확장성이 뛰어나다. 반면에 memcached는 클러스터링을 지원하지 않고, 클라이언트 측에서 수동으로 데이터를 분산해야 해서 분산 캐싱이 redis에 비해 유연하지 않다.

확장성: Redis는 메모리를 사용하는 것 외에도 디스크, 클러스터링, 리플리케이션 등 다양한 확장성을 제공한다. Memcached는 단순한 메모리 캐시로서의 확장성이 뛰어나다.

기능: Redis는 다양한 고급 기능을 제공한다. 예를 들어, 트랜잭션, Pub/Sub 메시징, Lua 스크립팅, 비동기 쿼리 등의 기능을 지원한다. Memcached는 단순한 데이터 저장소로서의 기능만을 제공한다.

## JOIN에 대해서 설명해주세요.
JOIN은 관계형 데이터베이스에서 두 개 이상의 테이블(table) 간에 데이터를 조합하여 새로운 결과를 도출하는 연산이다.

## MongoDB에 대해서 간단히 설명해주세요.
MongoDB는 분산 데이터 저장과 수평 확장이 가능하도록 설계되어 있는 NoSQL 데이터베이스이다. 스키마가 없는(schemaless) 구조를 가지고 있어서 데이터 모델링이 유연하고 쉽우며, 문서 내에 중첩 구조를 사용해 데이터 중복을 최소화하면서 읽기 성능을 높일 수 있다. 이런 장점을 살려서 텍스트, 이미지, 비디오, 로그 데이터 등 비정형 데이터를 주로 저장한다.

## CAP 이론과, Eventual Consistency에 대해서 설명해주세요.
CAP 이론은 분산 컴퓨팅 시스템에서 일관성(Consistency), 가용성(Availability), 분할 내성(Partition Tolerance) 중에서 최대 두 가지만 선택할 수 있다는 것을 말한다.
Consistency - 모든 노드에서 동일한 데이터가 반환되는 것을 의미한다.
Availability - 언제나 요청에 대해 응답이 가능한 것을 의미한다.. 
Partition Tolerance - 네트워크 분할 시스템이 정상적으로 동작할 수 있는 것을 의미한다.

Eventual Consistency는 CAP 이론에서 일관성을 포기하고 가용성과 분할 내성을 선택하는 것을 의미하는데, 일관성을 포기해서 시스템의 모든 노드가 동일한 상태를 유지하지 않지만, 시간이 지남에 따라 모든 노드가 동일한 상태로 수렴하도록 하는 방법을 의미한다. 데이터의 일관성을 보장하지 않으므로 일부 시스템에서는 적합하지 않을 수 있지만, 대규모 데이터베이스나 분산 시스템에서는 가용성과 분할 내성을 중점으로 해서 대용량 데이터를 처리한다.

## Cardinality란?
카디널리티(Cardinality)란, 관계형 데이터베이스에서 데이터의 중복 없이 고유한 값을 가지는 특정 컬럼(column)의 종류의 수를 말한다. 즉, 특정 컬럼에 포함된 고유한 값의 개수를 의미합니다. 예를 들어, 주문 테이블에서 주문 번호(order number)는 고유한 값이므로 카디널리티가 높지 않지만, 고객 테이블에서 고객의 이름(name)은 중복될 가능성이 있으므로 카디널리티가 높을 수 있다. 카디널리티가 높은 컬럼은 인덱스를 사용해도 검색 속도가 느리거나 인덱스가 복잡해지므로, 인덱스 설정시 고려해야하는 사항이다.
