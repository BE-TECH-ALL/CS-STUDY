## 데이터베이스에서 인덱스를 사용하는 이유 및 장단점에 대해 설명해주세요.
데이터베이스에서 인덱스를 사용하는 이유는 검색성능을 향상시키기 위함입니다.

하지만 검색성능을 실질적으로 향상시키기 위해서는 해당 쿼리가 index를 사용하는지, cardinality, 분포도(Selectivity) 같은 요소들이 고려된 인덱스가 생성되어야 합니다.

일반적인 경우의 장점으로는 빠른 검색 성능을 들 수 있습니다.

일반적인 경우의 단점으로는 인덱스를 구성하는 비용 즉, 추가, 수정, 삭제 연산시에 인덱스를 형성하기 위한 추가적인 연산이 수행됩니다.

따라서, 인덱스를 생성할 때에는 트레이드 오프 관계에 놓여있는 요소들을 종합적으로 고려하여 생성해야합니다.

#### | cardinality
중복도가 ‘낮으면’ 카디널리티가 ‘높다’고 표현한다.
중복도가 ‘높으면’ 카디널리티가 ‘낮다’고 표현한다.
카디널리티는 전체 행에 대한 특정 컬럼의 중복 수치를 나타내는 지표이다.

## 트랜잭션에 대해서 설명해주세요.
트랜잭션이란 데이터베이스의 상태를 변화시키는 하나의 논리적인 작업 단위라고 할 수 있으며, 트랜잭션에는 여러개의 연산이 수행될 수 있습니다.

트랜잭션은 수행중에 한 작업이라도 실패하면 전부 실패하고, 모두 성공해야 성공이라고 할 수 있습니다.

## ACID에 대해서 설명해주세요.
ACID는 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질입니다.

- Atomicity(원자성): 트랜잭션의 연산은 모든 연산이 완벽히 수행되어야 하며, 한 연산이라도 실패하면 트랜잭션은 실패해야 합니다.
- Consistency(일관성): 하나의 트랜잭션 이전과 이후, 데이터베이스의 상태는 이전과 같이 유효해야 한다.
- Isolation(고립성): 트랜잭션은 동시에 실행될 경우 다른 트랜잭션에 의해 영향을 받지 않고 독립적으로 실행되어야 합니다.
- Durability(내구성): 하나의 트랜잭션이 성공적으로 수행되었다면, 해당 트랜잭션에 대한 로그가 남아야하는 성질을 말한다.

#### | 일관성 추가내용
예를 들어 ‘모든 고객은 반드시 이름을 가지고 있어야 한다’는 데이터베이스의 제약이 있다고 가정한다.
다음과 같은 트랜잭션은 Consistency(일관성)를 위반한다.
1. 이름 없는 새로운 고객을 추가하는 쿼리
2. 기존 고객의 이름을 삭제하는 쿼리
데이터베이스의 유효한 상태는 다를수 있지만, 데이터의 상태에 대한 일관성은 변하지 않아야 한다.
이 예시는 ‘이름이 있어야 한다’ 라는 제약을 위반한다.
따라서 예시 트랜잭션이 일어난 이후의 데이터베이스는 일관되지 않는 상태를 가지게 된다.

## 트랜잭션 격리 수준(Transaction Isolation Levels)에 대해서 설명해주세요.
동시에 여러 트랜잭션이 처리될 때, 트랜잭션끼리 얼마나 서로 고립되어 있는지를 나타내는 것이다.
즉, 간단하게 말해 특정 트랜잭션이 다른 트랜잭션에 변경한 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것이다.

아래로 내려갈수록 트랜잭션간 고립 정도가 높아지며, 성능이 떨어지는 것이 일반적이다.
- READ UNCOMMITTED: 다른 트랜잭션에서 커밋되지 않은 내용도 참조할 수 있다.
- READ COMMITTED: 다른 트랜잭션에서 커밋된 내용만 참조할 수 있다.
- REPEATABLE READ: 트랜잭션에 진입하기 이전에 커밋된 내용만 참조할 수 있다.
- SERIALIZABLE: 트랜잭션에 진입하면 락을 걸어 다른 트랜잭션이 접근하지 못하게 한다.(성능 매우 떨어짐)

## 정규화에 대해서 설명해주세요.
정규화는 데이터의 중복방지, 무결성을 충족시키기 위해 데이터베이스를 설계하는 것을 의미합니다.
데이터 무결성은 데이터의 정확성, 일관성, 유효성이 유지되는 것을 의미

## JOIN에 대해서 설명해주세요.
두개 이상의 테이블을 결합하여 데이터를 검색하는 방법입니다.

#### 기본 JOIN (= INNER JOIN) : 두 테이블의 교집합
#### LEFT JOIN : 왼쪽 테이블을 중심으로 오른쪽의 테이블을 매치


## RDBMS vs NOSQL에 대해서 설명해주세요.
RDBMS는 데이터베이스를 이루는 객체들의 릴레이션을 통해서 데이터를 저장하는 데이터베이스입니다. 
SQL을 사용해 데이터의 저장, 질의, 수정, 삭제를 할 수 있으며 데이터를 효율적으로 보관하는 것을 목적으로 하고 구조화가 굉장히 중요합니다.

장점으로는 명확한 데이터 구조를 보장하고, 중복을 피할 수 있습니다.

NOSQL은 RDBMS에 비해 자유로운 형태로 데이터를 저장합니다. 또한 수평확장을 할 수 있고 분산처리를 지원합니다. 다양한 형태의 NOSQL 데이터베이스가 있고, 대표적으로 key-value store, bigtable, dynamo, document db, graph db 등이 있습니다.

둘은 대체될 수 있는 것이 아니고, 각각 필요한 시점에 적절히 선택해서 사용해야 합니다. 둘 다 같이쓰는 상호보완적인 존재가 될 수도 있습니다.

## Redis에 대해서 간단히 설명해주세요.
Redis는 key-value store NOSQL DB입니다. 싱글스레드로 동작하며 자료구조를 지원합니다. 그리고 다양한 용도로 사용될 수 있도록 다양한 기능을 지원합니다. 
데이터의 스냅샷 혹은 AOF 로그를 통해 복구가 가능해서 어느정도 영속성도 보장됩니다.

스프링에서는 세션을 관리하거나, 캐싱을 하는데에 자주 사용되는 것으로 알고 있습니다.

#### | AOF
- Append Only File의 약자로, 적재, 수정, 삭제 명령이 실행될 때마다 파일에 기록되며 수정이 가능합니다.
- 파라미터에 따라 '명령어가 수행될 때마다; 1초마다; OS 에서 알아서' 방식으로 디스크에 쓰여집니다.

## Redis와 Memcached의 차이에 대해서 설명해주세요.
Redis는 싱글 스레드 기반으로 동작하고, Memcached는 멀티스레드를 지원합니다.
Redis는 다양한 자료구조를 지원하고, Memcached는 문자열 형태로만 저장합니다.
Redis는 여러 용도로 사용할 수 있도록 다양한 기능을 지원합니다.
Redis는 스냅샷, AOF 로그를 통해서 데이터 복구가 가능합니다.

## Elastic Search에 대해서 간단히 설명해주세요.
Elastic Search는 자바로 개발된 오픈소스 검색엔진 입니다. 보통 단독으로 사용하기보다는 ELK 스택이라고 부르는 Logstash, Kibana, Beats를 추가적으로 사용합니다.
Inverted Index 구조로 데이터를 저장해서, 전문(Full-text) 검색시에 RDBMS에 비해 뛰어난 성능을 보장합니다.
다양한 용도로 사용할 수 있습니다. (데이터 저장, 문서 검색, 위치 검색, 머신 러닝 기반 검색, 로그 분석, 보안 감사 분석 등)


## Elastic Search의 인덱스구조와 RDBMS의 인덱스 구조의 차이에 대해 설명해주세요.
- Elasticsearch는 역색인 자료 구조로 검색을 수행하지만, RDBMS는 인덱스 자료 구조로 검색을 수행한다.
- 역색인은 키워드를 통해 문서를 찾는 방식이다.

## Elastic Search의 키워드 검색과 RDBMS의 LIKE 검색의 차이에 대해 설명해주세요.
관계형 데이터베이스는 단순 텍스트매칭에 대한 검색만을 제공합니다.
MySQL 최신 버전에서 n-gram 기반의 Full-text 검색을 지원하지만, 한글 검색의 경우에 아직 많이 빈약한 감이 있습니다.

## CAP 이론과, Eventual Consistency에 대해서 설명해주세요.
#### | CAP 이론은 분산 환경에서 모두를 만족하는 시스템은 없다는 이론입니다.
- Consitenty(일관성): ACID의 일관성과는 약간 다릅니다. 모든 노드가 같은 시간에 같은 데이터를 보여줘야 한다는 것입니다.
- Availability(가용성): 모든 동작에 대한 응답이 리턴되어야 합니다.
- Partition Tolerance(분할 내성): 시스템 일부가 네트워크에서 연결이 끊기더라도 동작해야 합니다.


#### | Eventual Consistency
분산 시스템을 구성하려면 CAP 이론에 의해서 일관성과 가용성 중 하나를 포기해야하는 상황이 올 수 있습니다.
클라이언트의 요청을 받았을 때, A서버의 데이터가 변경되면 즉시 다른 서버에 반영되지 않습니다. 아래 두가지 경우가 있습니다.
모든 서버가 동일한 데이터를 갖도록 동기화 하는동안 클라이언트의 접근을 막는 경우 (가용성의 문제)
다른 클라이언트들이 변경된 데이터를 요청했을 때 어떤 클라이언트는 최신의 데이터를, 어떤 클라이언트는 오래된 데이터를 받게되는 경우.(일관성의 문제)
그러나 2번의 경우 언젠가는 동기화가 되면, 모든 클라이언트가 동일한 데이터를 받아볼 수 있게 됩니다.
이것이 Eventual Consistency  입니다.
