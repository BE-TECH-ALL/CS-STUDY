## 프로세스와 스레드의 차이를 설명해보세요.
프로세스는 운영체제에 의해 관리되는 독립적인 실행 단위이고, 스레드는 프로세스 내부에서 실행되는 작업의 단위입니다. 프로세스는 자신만의 메모리 공간을 가지고 서로 메모리 공간을 
공유하지 않는 반면에 스레드는 stack 영역을 제외한 Code, Data, Heap 영역을 공유합니다. 이러한 차이점 때문에 프로세스의 경우 른 프로세스와 자원을 공유하거나, 프로세스 간에 데이터를 
직접 전달하는 것이 스레드에 비해서 어렵습니다. 스레드의 경우 메모리를 공유하기 때문에 데이터를 주고 받는 것은 프로세스보다 빠르고 편하지만, 공유하는 자원을 서로 수정, 조회 등의 작업을
하는 경우 데이터 일관성, 동기화 문제가 발생할 수 있습니다.

## 컨텍스트 스위칭에 대해 설명해보세요.
컨텍스트 스위칭은 현재 실행 중인 프로세스나 스레드의 상태를 저장하고, 다음 실행할 프로세스나 스레드의 상태를 불러와 CPU를 할당하는 작업입니다. 컨텍스트란 프로세스 혹은 스레드의 상태
정보를 의미하는데, 이것을 서로 스위칭하며 여러개의 프로세스 / 스레드를 동시에 작동할 수 있게 합니다. 컨텍스트 스위칭을 사용해서 동시에 여러 프로세스 / 스레드를 작동시키면 병렬처리,
빠른 응답 등의 장점이 있지만 그만큼 전체 시스템의 성능에 영향을 미치는 단점이 있습니다.

## 동기와 비동기의 차이(블로킹, 넌블로킹) / 장단점에 대해 설명해보세요.
동기(Synchronous)의 경우, 호출한 함수가 바로 처리 결과를 반환하며 호출된 함수가 모두 처리될 때까지 대기합니다. 이러한 방식은 코드의 직관성이 좋지만 호출된 함수가 완료될 때까지 대기하기 
때문에 처리 시간이 길어지는 작업에서는 전체 시스템의 성능이 저하될 수 있습니다.

비동기(Asynchronous)의 경우 호출한 함수가 바로 처리 결과를 반환하지 않으며, 호출된 함수는 백그라운드에서 비동기적으로 처리됩니다. 이러한 방식은 호출한 함수가 호출된 함수의 작업 결과를 
기다리지 않고 다음 작업을 수행할 수 있으므로 시스템의 성능이 향상될 수 있습니다. 하지만 비동기 방식은 코드의 직관성이 떨어지고, 호출된 함수의 처리 결과를 기다리지 않기 때문에 
호출된 함수가 완료되지 않은 상태에서 다른 작업을 수행하는 경우에는 별도의 처리가 필요합니다.

블로킹(Blocking)은 호출한 함수가 처리 결과를 반환할 때까지 대기하는 방식입니다. 예를 들어, 파일을 읽거나 쓰는 I/O 작업에서는 블로킹 방식으로 처리합니다. 이러한 방식은 코드의 
직관성이 높지만, 호출된 함수가 완료될 때까지 대기해야 하기 때문에 다른 작업을 수행할 수 없고, 전체 시스템의 성능이 저하될 수 있습니다.

넌블로킹(Non-Blocking)은 호출한 함수가 처리 결과를 기다리지 않고 바로 반환되는 방식입니다. 호출한 함수는 다른 작업을 수행할 수 있으며 호출된 함수는 백그라운드에서 처리됩니다. 
이러한 방식은 호출한 함수가 다른 작업을 수행할 수 있기 때문에 시스템의 성능이 향상될 수 있습니다. 하지만 호출된 함수가 처리 결과를 반환할 때까지 지속적으로 호출되는 방식이기 
때문에, 코드의 복잡성이 증가하고 오류 처리가 복잡해질 수 있습니다.

## 멀티스레드 프로그래밍에 대해 설명해보세요.
멀티스레드 프로그래밍은 하나의 프로세스 안에서 여러 개의 스레드를 사용하여 여러 개의 작업을 동시에 수행하는 프로그래밍 방식입니다.
멀티스레드 프로그래밍에서는 하나의 프로세스 내에서 각각의 스레드가 병렬로 실행되며 이를 통해 여러 개의 작업을 동시에 처리할 수 있습니다. 예를 들어 웹 브라우저에서는 한 스레드가 
사용자의 입력을 받고, 다른 스레드가 웹 페이지를 다운로드하고, 또 다른 스레드가 다운로드한 내용을 화면에 출력합니다.

- 장점
  - 높은 처리 성능: 각각의 스레드가 독립적으로 작업을 수행하기 때문에 여러 개의 작업을 동시에 처리할 수 있습니다. 이를 통해 전체적인 처리 성능을 높일 수 있습니다.
  - 빠른 응답 시간: 스레드들이 동시에 작업을 수행하기 때문에 작업이 완료될 때까지 대기할 필요가 없습니다. 따라서 시스템의 응답 시간이 빨라집니다.
  - 자원 공유: 하나의 프로세스 내에서 스레드들이 메모리 공간 등의 자원을 공유하기 때문에 프로세스 간 통신과 같은 복잡한 작업을 처리하는 데에 용이합니다.
  - 코드 간결성: 멀티스레드 프로그래밍을 통해 병렬 처리를 구현할 수 있기 때문에 코드의 간결성을 높일 수 있습니다.
  
- 단점
  - 복잡성: 여러 개의 스레드가 동시에 작업을 수행하므로 스레드 간의 동기화와 같은 문제를 처리해야 하며, 이로 인해 코드가 복잡해질 수 있습니다.
  - 스레드 간 경쟁: 여러 개의 스레드가 동시에 자원을 공유하기 때문에, 스레드 간의 경쟁 문제가 발생할 수 있습니다. 이를 해결하기 위해서는 스레드 간의 동기화를 보장해야 하며, 이는 코드의 복잡성을 높이게 됩니다.
  - 데드락: 스레드 간의 자원 공유와 경쟁이 발생하기 때문에, 데드락(deadlock)과 같은 문제가 발생할 가능성이 있습니다.
  - 성능 저하: 스레드 간의 동기화를 위한 오버헤드가 발생하기 때문에, 스레드 수가 많아질수록 전체적인 처리 성능이 저하될 수 있습니다.

## Thread-safe 하다는 의미와 설계하는 법을 설명해보세요.
Thread-safe는 멀티스레드 환경에서 여러 스레드가 동시에 공유 자원을 사용할 때, 언제나 정확한 결과를 보장하는 것을 의미합니다.
설계하는 방법으로는 공유 자원 접근 제한, 공유 자원을 불변성(immutable)으로 유지, 스레드 로컬 스토리지 사용, 락(lock)을 사용하는 방법 등이 있습니다.

## 프로세스 동기화에 대해 설명해보세요.
프로세스 동기화는 멀티프로세스 환경에서 프로세스 간의 작업이 서로 영향을 주지 않도록 하기 위한 방법입니다. 이를 실현하기 위해서 여러개의 프로세스가 있는 경우 하나의 프로세스만
자원에 접근 가능하도록 하는 것입니다. 이러한 방법으로 뮤텍스, 세마포어와 같은 방법들이 사용됩니다.

## 교착상태와 기아상태의 해결방법에 대해 설명해보세요.
교착상태(Deadlock)는 멀티프로세스나 멀티스레드 환경에서 두 개 이상의 프로세스나 스레드가 서로가 가지고 있는 자원을 점유하고 있으면서, 상대방이 점유한 자원을 요청하며, 
서로가 요청한 자원을 갖고 있기 위해 무한히 대기하는 상태를 말합니다. 

기아상태(Starvation)는 멀티프로세스나 멀티스레드 환경에서 특정 프로세스나 스레드가 필요한 자원을 계속해서 얻지 못하여 무한정 기다리는 상태를 말합니다.

교착상태의 발생조건은 다음과 같습니다.
1. 상호 배제: 한 번에 한 프로세스만 해당 자원을 사용할 수 있어야 합니다.
2. 점유 대기: 할당된 자원을 가진 상태에서 다른 자원을 기다립니다.
3. 비선점: 다른 프로세스가 자원의 사용을 끝낼 때 까지 자원을 뺏을 수 없습니다.
4. 순환대기: 각 프로세스가 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있습니다.

교착상태의 해결방법으로는 다음과 같습니다.
1. 예방: 4가지 조건 중 하나라도 만족되지 않도록 합니다.
2. 회피: 알고리즘을 데드락이 발생하지 않도록 합니다.
3. 회복: 교착상태가 발생할 때, 해결합니다.
4. 무시: 회복과정의 성능저하가 심하다면 그냥 무시합니다.

기아상태의 해결방법으로는 다음과 같습니다.
1. 우선순위 스케줄링(Priority Scheduling): 자원을 요청한 프로세스나 스레드 중 우선순위가 높은 프로세스나 스레드에게 자원을 할당하는 방식입니다.
2. 공정성 보장(Fairness Guarantee): 자원을 요청한 프로세스나 스레드에게 자원을 공정하게 분배합니다.

## 세마포어와 뮤텍스의 차이에 대해 설명해보세요.
뮤텍스는 공유 자원에 대한 접근을 하나의 스레드만 가능하도록 제한하며 다른 스레드가 공유 자원을 사용하지 못하도록 합니다. 따라서 뮤텍스는 공유 자원에 대한 접근을 보호하기 위한 
목적으로 사용됩니다.

세마포어는 공유 자원의 사용 가능한 수를 나타내는 카운터를 가지고 있습니다. 스레드는 세마포어 값을 확인하여 공유 자원에 접근할 수 있는지 확인합니다. 따라서 세마포어는 공유 자원을 
제한된 수의 스레드가 동시에 접근할 수 있도록 제어하기 위한 목적으로 사용됩니다.

뮤텍스는 임계 영역(Critical Section)을 보호하는 데 사용됩니다. 임계 영역이란 여러 스레드가 동시에 접근하면 문제가 발생하는 코드 영역을 말합니다. 따라서, 뮤텍스는 임계 영역에 대한 
접근을 동기화합니다. 반면에 세마포어는 임계 영역 뿐만 아니라 공유 자원 전체에 대한 접근을 동기화합니다. 따라서 세마포어는 여러 개의 스레드가 동시에 접근하는 코드 영역을 보호할 수 있습니다.

## 가상 메모리에 대해 설명해보세요.
가상 메모리(Virtual Memory)는 프로그램이 실행되기 위해 필요한 메모리 공간을 디스크와 같은 보조 기억 장치에 할당하고, 필요한 경우 주 메모리(RAM)로 로드하는 기술입니다.
이를 통해 실제 물리적 메모리(RAM)보다 큰 메모리 공간을 사용할 수 있게 만들어 줍니다. 

가상 메모리는 실제 메모리(RAM, main memory, first storage)와 보조 기억 장치(auxiliary storage, secondary storage)의 Swap 영역으로 구성됩니다.
OS 는 메모리 관리자(Memory Management Unit)를 통해 메모리를 관리하며 프로세스는 사용하는 메모리가 실제 메모리인지, Swap 영역인지 모릅니다.

## 캐시의 지역성에 대해 설명해보세요.
캐시(Cache)는 CPU가 빠르게 데이터에 접근할 수 있도록 메모리 계층 구조 중 가장 빠른 속도를 가진 메모리입니다.
캐시의 지역성(Locality)이란, CPU가 참조하는 데이터나 명령어가 시간적으로나 공간적으로 근접한 위치에 위치하는 경향을 말합니다. 지역성은 크게 시간 지역성(Temporal Locality)과 
공간 지역성(Spatial Locality)으로 나뉩니다.

시간 지역성은 CPU가 한 번 접근한 데이터나 명령어를 다시 사용할 가능성이 높다는 것을 의미합니다. 예를 들어 반복문에서 동일한 데이터나 명령어를 반복적으로 사용하는 경우 해당 데이터나 
명령어는 캐시에 자주 저장됩니다. 이를 통해 CPU가 데이터나 명령어에 대한 접근 시간을 줄일 수 있습니다.

공간 지역성은 CPU가 참조한 데이터나 명령어 주변에 위치한 데이터나 명령어를 다음에 참조할 가능성이 높다는 것을 의미합니다. 예를 들어 배열을 순차적으로 접근하는 경우 해당 배열 
데이터는 캐시에 일정한 영역 안에 자주 저장됩니다. 이를 통해 CPU가 다음에 참조할 데이터나 명령어에 대한 접근 시간을 줄일 수 있습니다.
