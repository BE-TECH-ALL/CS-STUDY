## Java의 특징을 설명해주세요.
Java는 객체지향 프로그래밍 언어입니다.
기본 자료형을 제외한 모든 요소들이 객체로 표현되고, 객체 지향 개념의 특징인 캡슐화, 상속, 다형성이 잘 적용된 언어입니다.

장점 :
- JVM(자바가상머신) 위에서 동작하기 때문에 운영체제에 독립적이다.
- GabageCollector를 통한 자동적인 메모리 관리가 가능하다.

단점 :
- JVM 위에서 동작하기 때문에 실행 속도가 상대적으로 느리다.
- 다중 상속이나 타입에 엄격하며, 제약이 많다.

## JVM의 역할에 대해 설명해주세요.
JVM은 스택 기반으로 동작하며, Java Byte Code를 OS에 맞게 해석 해주는 역할을 하고 가비지컬렉션을 통해 자동적인 메모리 관리를 해줍니다.

## Java의 컴파일 과정에 대해 설명해주세요.
1. 개발자가 .java 파일을 생성한다.
2. build를 한다.
3. java compiler의 javac의 명령어를 통해 바이트코드(.class)를 생성한다.
4. Class Loader를 통해 JVM 메모리 내로 로드한다.
5. 실행엔진을 통해 컴퓨터가 읽을 수 있는 기계어로 해석된다.(각 운영체제에 맞는 기계어)

## 불변 객체가 무엇인지 설명하고 대표적인 Java의 예시를 설명해주세요.
불변 객체는 객체 생성 이후 내부의 상태가 변하지 않는 객체를 말합니다. Java에서는 필드가 원시 타입인 경우 final 키워드를 사용해 불변 객체를 만들 수 있고, 참조 타입일 경우엔 추가적인 작업이 필요합니다.

## 참조 타입일 경우 추가적인 작업은 어떤게 있는지 설명해주세요.
참조 타입은 대표적으로 1.객체를 참조할 수도 있고, 2.배열이나 3.List 등을 참조할 수 있습니다.

1. 참조 변수가 일반 객체인 경우 객체를 사용하는 필드의 참조 변수도 불변 객체로 변경해야 합니다.

2. 배열일 경우 배열을 받아 copy해서 저장하고, getter를 clone으로 반환하도록 하면 됩니다.
(배열을 그대로 참조하거나, 반환할 경우 외부에서 내부 값을 변경할 수 있음. 때문에 clone을 반환해 외부에서 값 변경하지 못하게 함)

3. 리스트인 경우에도 배열과 마찬가지로 생성시 새로운 List를 만들어 값을 복사하도록 해야 합니다.
배열과 리스트는 내부를 복사하여 전달하는데, 이를 방어적 복사(defensive-copy)라고 합니다.

## 불변 객체나 final을 굳이 사용해야 하는 이유는?
1. Thread-Safe하여 병렬 프로그래밍에 유용하며, 동기화를 고려하지 않아도 된다.
(공유 자원이 불변이기 때문에 항상 동일한 값을 반환하기 때문)

2. 실패 원자적인 메소드를 만들 수 있다.
(어떠한 예외가 발생되더라도 메소드 호출 전의 상태를 유지할 수 있어 예외 발생 전과 똑같은 상태로 다음 로직 처리 가능)

3. 부수효과를 피해 오류를 최소화 할 수 있다.
(부수효과 : 변수의 값이 바뀌거나 객체의 필드 값을 설정하거나 예외나 오류가 발생하여 실행이 중단되는 현상)

4. 메소드 호출 시 파라미터 값이 변하지 않는다는 것을 보장할 수 있다.
5. 가비지 컬렉션 성능을 높일 수 있다.
(가비지 컬렉터가 스캔하는 객체의 수가 줄기 때문에 Gc 수행 시 지연시간도 줄어든다.)

## 추상 클래스와 인터페이스를 설명해주시고, 차이에 대해 설명해주세요.
추상 클래스는 클래스 내 추상 메소드가 하나 이상 포함되거나 abstract로 정의된 경우를 말하고,
인터페이스는 모든 메소드가 추상 메소드로만 이루어져 있는 것을 말합니다.

공통점 :
- new 연산자로 인스턴스 생성 불가능
- 사용하기 위해서는 하위 클래스에서 확장/구현 해야 한다.

차이점 :
- 인터페이스는 그 인터페이스를 구현하는 모든 클래스에 대해 특정한 메소드가 반드시 존재하도록 강제함에 있고, 추상클래스는 상속받는 클래스들의 공통적인 로직을 추상화 시키고, 기능 확장을 위해 사용한다.
- 추상클래스는 다중상속이 불가능하지만, 인터페이스는 다중상속이 가능하다.

## 싱글톤 패턴에 대해 설명해주세요.
- 싱글톤 패턴은 단 하나의 인스턴스를 생성해 사용하는 디자인 패턴입니다.
- 인스턴스가 1개만 존재해야 한다는 것을 보장하고 싶은 경우와
- 동일한 인스턴스를 자주 생성해야 하는 경우에 주로 사용합니다. (메모리 낭비 방지)

- 싱글톤 패턴의 대표적인 예시는 Spring Bean 입니다. 스프링의 빈 등록 방식은 기본적으로 싱글톤 스코프이고, 스프링 컨테이너는 모든 빈들을 싱글톤으로 관리합니다.
- 스프링은 요청할 때마다 새로운 객체를 생성해서 반환하는 기능도 제공한다. (프로토타입 빈, @Scope("prototype"))

## 가비지 컬렉션(Garbage Collection)에 대해 설명해주세요.
가비지 컬렉션은 JVM의 메모리 관리 기법 중 하나로 시스템에서 동적으로 할당됐던 메모리 영역 중에서 필요없어진 메모리 영역을 회수하여 메모리를 관리해주는 기법입니다.

GC의 작업을 수행하기 위해 JVM이 어플리케이션의 실행을 잠시 멈추고, GC를 실행하는 쓰레드를 제외한 모든 쓰레드들의 작업을 중단 후 (Stop The World 과정) 사용하지 않는 메모리를 제거(Mark and Sweep 과정)하고 작업이 재개됩니다.
(GC의 작업은 Young 영역에 대한 Minor GC와 Old 영역에 대한 Major GC로 구분됩니다.)

## 자바의 메모리 영역에 대해 설명해주세요.
자바의 메모리 공간은 크게 Method 영역, Stack 영역, Heap 영역으로 구분되고, 데이터 타입에 따라 할당됩니다.

- 메소드(Method) 영역 : 전역변수와 static변수를 저장하며, Method영역은 프로그램의 시작부터 종료까지 메모리에 남아있다.
- 스택(Stack) 영역 : 지역변수와 매개변수 데이터 값이 저장되는 공간이며, 메소드가 호출될 때 메모리에 할당되고 종료되면 메모리가 해제된다. LIFO(Last In First Out) 구조를 갖고 변수에 새로운 데이터가 할당되면 이전 데이터는 지워진다.
- 힙(Heap) 영역 : new 키워드로 생성되는 객체(인스턴스), 배열 등이 Heap 영역에 저장되며, 가비지 컬렉션에 의해 메모리가 관리되어 진다.

각 메모리 영역이 할당되는 시점:
- Method 영역 : JVM이 동작해서 클래스가 로딩될 때 생성
- Stack 영역 : 컴파일 타임 시 할당 (컴파일 타임 : 소스코드가 기계어로 변환되어 실행가능한 프로그램이 되는 과정)
- Heap 영역 : 런타임시 할당 (런타임 : 컴파일 타임 이후 프로그램이 실행되는 때)

## 클래스와 객체에 대해 설명해주세요.
클래스는 객체를 만들어내기 위한 설계도 혹은 틀 이라고 할 수 있고, 객체를 생성하는데 사용합니다.
객체는 설계도(클래스)를 기반으로 생성되며, 자신의 고유 이름과 상태, 행동을 갖습니다.
여기서 상태는 필드(fields), 행동은 메소드(Method)라고 표현합니다.
객체에 메모리가 할당되어 실제로 활용되는 실체는 '인스턴스'라고 부릅니다.

## 생성자(Constructor)에 대해 설명해주세요.
생성자는 클래스와 같은 이름의 메소드로, 객체가 생성될 때 호출되는 메소드입니다.
명시적으로 생성자를 만들지 않아도 default로 만들어지며, 생성자는 파라미터를 다르게하여 오버로딩할 수 있습니다.

##  String 객체가 불변인 이유는?
1. 캐싱 기능에 의한 메모리 절약과 속도 향상
- Java에서 String 객체들은 Heap의 String Pool 이라는 공간에 저장되는데, 참조하려는 문자열이 String Pool에 존재하는 경우 새로 생성하지 않고 Pool에 있는 객체를 사용하기 때문에 특정 문자열 값을 재사용하는 빈도가 높을 수록 상당한 성능 향상을 기대할 수 있다.

2. thread-safe
- String 객체는 불변이기 때문에 여러 쓰레드에서 동시에 특정 String 객체를 참조하더라도 안전하다.

3. 보안기능
- 중요한 데이터를 문자열로 다루는 경우 강제로 해당 참조에 대한 문자열 값을 바꾸는 것이 불가능하기 때문에 보안에 유리하다.

## new String()과 리터럴("")의 차이에 대해 설명해주세요.
- new String()은 new 키워드로 새로운 객체를 생성하기 때문에 Heap 메모리 영역에 저장되고,
- ""는 Heap 안에 있는 String Constant Pool 영역에 저장됩니다.

## Synchronized란?
- 여러 개의 쓰레드가 한 개의 자원을 사용하고자 할 때, 현재 데이터를 사용하고 있는 쓰레드를 제외하고 나머지 쓰레드들은 데이터에 접근할 수 없게 막는 개념입니다.
- 데이터의 thread-safe를 하기 위해 자바에서 Synchronized 키워드를 제공해 멀티 쓰레드 환경에서 쓰레드간 동기화를 시켜 데이터의 thread-safe를 보장합니다.
- Synchronized는 변수와 메소드에 사용해서 동기화 할 수 있으며, Synchronized 키워드를 남발하게 되면 오히려 프로그램의 성능저하를 일으킬 수 있습니다.

## Wrapper Class란 무엇이며, Boxing과 UnBoxing은 무엇인지 설명해주세요.
- 기본 자료형(Primitive data type)에 대한 객체 표현을 Wrapper class라고 합니다.
- Boxing : 기본 자료형 → Wrapper class로 변환
- UnBoxing : Wrapper class → 기본 자료형으로 변환

## 클래스 멤버 변수 초기화 순서에 대해 설명해주세요.
- static 변수 선언부 : 클래스가 로드 될 때 변수가 제일 먼저 초기화 된다.
- 필드 변수 선언부 : 객체가 생성될 때 생성자 block 보다 앞서 초기화 된다.
- 생성자 block : 객체가 생성될 때 JVM이 내부적으로 locking( thread-safe 영역 )

## static에 대해 설명해주세요.
- static 키워드를 사용한 변수나 메소드는 클래스가 메모리에 올라갈 때 자동으로 생성되며 클래스 로딩이 끝나면 바로 사용할 수 있습니다. 즉, 인스턴스(객체) 생성 없이 바로 사용 가능합니다.
- 모든 객체가 메모리를 공유한다는 특징이 있고, GC 관리 영역 밖에 있기 때문에 프로그램이 종료될 때까지 메모리에 값이 유지된 채로 존재하게 됩니다.
- static은 자주 변하지 않는 값이나 공통으로 사용되는 값 같은 공용자원에 대한 접근에 있어서 매번 메모리에 로딩하거나 값을 읽어들이는 것보다 일종의 '전역변수'와 같은 개념을 통해 접근하는 것이 비용도 줄이고 효율을 높일 수 있습니다.
- 인스턴스 생성 없이 바로 사용 가능하기 때문에 프로그램 내에서 공통으로 사용되는 데이터들을 관리할 때 이용합니다.

## Inner Class(내부 클래스)의 장점에 대해 설명해주세요.
- 내부 클래스에서 외부 클래스의 멤버에 손쉽게 접근할 수 있다.
- 서로 관련 있는 클래스를 논리적으로 묶어서 표현함으로써, 캡슐화를 증가시키고, 코드의 복잡성을 낮출 수 있다.
- 외부에서는 내부 클래스에 접근할 수 없으므로, 코드의 보안성을 높일 수 있다.

## 리플렉션(Reflection)이란 무엇인지 설명해주세요.
- 리플렉션이란 구체적인 클래스 타입을 알지 못해도 그 클래스의 메소드, 타입, 변수들에 접근할 수 있도록 해주는 자바 API 입니다.
- 코드를 작성할 시점에는 어떤 타입의 클래스를 사용할지 모르지만, 런타임 시점에 지금 실행되고 있는 클래스를 가져와서 실행해야 하는 경우 사용됩니다.
- 프레임워크나 IDE에서 이런 동적인 바인딩을 이용한 기능을 제공합니다. intelliJ의 자동완성 기능, 스프링의 어노테이션이 리플렉션을 이용한 기능이라 할 수 있습니다.

## Error와 Exception의 차이를 설명해주세요.
Error는 실행 중 일어날 수 있는 치명적 오류를 말합니다. 컴파일 시점에 체크할 수 없고, 오류가 발생하면 프로그램은 비정상 종료되며 예측 불가능한 UncheckedException에 속합니다.
반면, Exception은 Error보다 비교적 경미한 오류이며, try-catch를 이용해 프로그램의 비정상 종료를 막을 수 있습니다.

## CheckedException과 UnCheckedException의 차이를 설명해주세요.
- CheckedException은 실행하기 전에 예측 가능한 예외를 말하고, 반드시 예외 처리를 해야 합니다.
(대표적인 Exception - IOException, ClassNotFoundException 등)

- UncheckedException은 실행하고 난 후에 알 수 있는 예외를 말하고, 따로 예외처리를 하지 않아도 됩니다.
(대표적인 Exception - NullPointerException, ArrayIndexOutOfBoundException 등)

- RuntimeException은 UncheckedException을 상속한 클래스이고, RuntimeException이 아닌 것은 CheckedException을 상속한 클래스 입니다.

## Optional API에 대해 설명해주세요.
NPE를 피하려면 null 여부 검사를 필연적으로 하게 되는데 만약 null 검사를 해야하는 변수가 많은 경우 코드가 복잡해지고 번거롭습니다. 하지만 Java8 부터 Optional<T>을 제공하여 null로 인한 예외가 발생하지 않도록 도와주고, Optional 클래스의 메소드를 통해 null을 컨트롤 할 수 있습니다.

## SerialVersionUID를 선언해야 하는 이유에 대해 설명해주세요.  
- JVM은 직렬화와 역직렬화를 하는 시점의 클래스에 대한 버전 번호를 부여하는데, 만약 그 시점에 클래스의 정의가 바뀌어 있다면 새로운 버전 번호를 할당하게 됩니다. 
  그래서 직렬화할 때의 버전 번호와 역직렬화를 할 때의 버전 번호가 다르면 역직렬화가 불가능하게 될 수 있기 때문에 이런 문제를 해결하기 위해 SerialVersionUID를 사용합니다.
- 만약 직렬화할 때 사용한 SerialVersionUID의 값과 역직렬화 하기 위해 사용했던 SVUID가 다르다면 InvalidClassException이 발생할 수 있다.
  
## 배열과 연결 리스트의 차이점은 무엇인가요?
배열은 연속된 메모리 공간에 원소를 저장하는 자료구조입니다. 크기가 고정되어 있고 인덱스를 통해 빠른 접근이 가능합니다. 반면 연결 리스트는 각 노드가 데이터와 다음 노드를 가리키는 포인터로 구성되며, 
동적으로 크기를 조정할 수 있습니다. 노드 사이에는 메모리가 연속적으로 배치되지 않으므로 삽입 및 삭제가 빈번한 경우 유리합니다.

## 스택과 큐의 차이점과 사용 예시를 설명해주세요.
- 스택은 후입선출(LIFO) 구조로 데이터를 저장하는 자료구조입니다. 데이터의 삽입과 삭제가 스택의 상단에서 이루어집니다. 주로 함수 호출, 재귀 알고리즘, 역추적 등에 사용됩니다. 
- 큐는 선입선출(FIFO) 구조로 동작하는 자료구조입니다. 데이터의 삽입은 큐의 뒤쪽(rear)에서, 삭제는 앞쪽(front)에서 이루어집니다. 작업 대기열, 네트워크 패킷 처리 등에 사용됩니다.

## 이진 검색 트리란 무엇인가요? 어떻게 구현하고 사용할 수 있을까요?
이진 검색 트리는 왼쪽 자식은 현재 노드보다 작은 값, 오른쪽 자식은 현재 노드보다 큰 값으로 정렬된 이진 트리입니다. 효율적인 탐색, 삽입, 삭제를 지원합니다. 이를 구현하기 위해 노드에는 값, 왼쪽 자식 노드, 
오른쪽 자식 노드를 저장하는 구조를 사용할 수 있습니다. 탐색 시간은 트리의 높이에 비례하며, 일반적으로 O(log n)의 시간 복잡도를 가집니다.

## 해시 테이블(해시 맵)의 개념과 작동 방식에 대해 설명해주세요.
해시 테이블은 키와 값을 쌍으로 저장하는 자료구조입니다. 키를 해시 함수를 통해 해시 값으로 변환한 후, 해당 값에 대응하는 인덱스에 데이터를 저장합니다. 작동 방식은 해시 함수가 고르게 분포되도록 해시 값 계산 후, 
충돌을 해결하기 위해 체이닝(연결 리스트 사용)이나 개방 주소법(충돌 시 다른 공간에 저장)을 이용합니다. 평균적으로 O(1)의 삽입, 삭제, 탐색 시간을 가지지만, 충돌이 자주 발생하면 성능이 저하될 수 있습니다.

## Hash Map과 Hash Table의 차이점에 대해 설명해주세요.
해시 테이블(Hash Table)
- 병렬 처리를 할 때 (동기화를 고려해야 하는 상황) Thread-safe 하다.
- Null 값을 허용하지 않는다.
  
해시 맵(Hash Map)
- 병렬 처리를 하지 않을 때 (동기화를 고려하지 않는 상황) Thread-safe하지 않는다.
- Null 값을 허용한다.

## Priority Queue(우선순위 큐)에 대해 설명해주세요.
우선순위 큐는 들어간 순서에 상관없이 우선순위가 높은 데이터를 먼저 꺼내기 위해 고안된 자료구조입니다.
우선순위 큐 구현 방식에는 배열, 연결 리스트, 힙이 있고, 그중 힙 방식이 worst case라도 시간 복잡도 O(logN)을 보장하기 때문에 일반적으로 완전 이진트리 형태의 힙을 이용해 구현합니다.
