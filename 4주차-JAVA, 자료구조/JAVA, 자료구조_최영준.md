# JAVA

## JVM의 구조와 Java의 실행방식을 설명해주세요.
JVM은 Java Virtual Machine이란 뜻으로, Java 언어로 작성된 프로그램을 실행하기 위한 가상 머신입니다. Java는 컴파일된 바이트 코드를 JVM에 전달하고, JVM은 이 바이트 코드를 기계어로 번역하고 실행합니다. JVM의 구조는 Class Loader, Execution engine, Runtime Data Area, JNI, Native Method Library로 이루어져 있습니다.

- Class Loader : JVM내로 클래스를 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈입니다. Java 클래스 파일은 JVM에서 실행하기 전에 먼저 로딩되어야 합니다.
- Execution engine : 바이트 코드를 실행시키는 역할을 합니다.
  - 인터프리터: 바이트 코드를 한줄 씩 실행합니다.
  - JIT 컴파일러: 인터피르터 효율을 높이기 위한 컴파일러로 인터프리터가 반복되는 코드를 발견하면 JIT 컴파일러가 반복되는 코드를 네이티브 코드로 바꿔줍니다. 그 다음부터 인터프리터는 네이티브 코드로 컴파일된 코드를 바로 사용합니다.
  - GC(Garbage Collector) : 가비지 컬렉터로 힙 영역에서 사용되지 않는 객체들을 제거하는 작업을 의미합니다.
- Runtime Data Areas: 프로그램 실행 중에 사용되는 다양한 영역입니다.
  - PC Register : Thread가 시작될 때 생성되며 현재 수행 중인 JVM 명령의 주소를 갖고 있습니다.
  - Stack Area : 지역 변수, 파라미터 등이 생성되는 영역. 실제 객체는 Heap에 할당되고 해당 레퍼런스만 Stack에 저장됩니다.
  - Heap Area : 동적으로 생성된 오브젝트와 배열이 저장되는 곳으로 GC의 대상 영역입니다.
  - Method Area : 클래스 멤버 변수, 메소드 정보, Type 정보, Constant Pool, static, final 변수 등이 생성됩니다. 상수 풀(Constant Pool)은 모든 Symbolic Reference를 포함하고 있습니다.
- JNI(Java Native Interface) : 자바 애플리케이션에서 C, C++, 어셈블리어로 작성된 함수를 사용할 수 있는 방법을 제공해줍니다. Native 키워드를 사용하여 메서드를 호출합니다. 대표적인 메서드는 Thread의 currentThread()입니다.
- Native Method Library : C, C++로 작성된 라이브러리 입니다.

Java의 실행방식
- 소스 코드 작성: Java 언어로 작성된 소스 코드를 작성합니다.

- 컴파일: Java 컴파일러(javac)를 사용하여 소스 코드를 바이트 코드로 변환합니다.

- 로딩: 클래스 로더가 바이트 코드를 로딩하여 Runtime Data Area의 Method Area에 저장합니다.

- 링크: 런타임 상수 풀(Constant Pool)이나 다른 클래스에 대한 참조를 해석하고, 필요한 메모리를 할당합니다.

- 초기화: 클래스 변수(static 변수)와 클래스 메서드(static method)를 위한 메모리를 할당하고 초기화합니다.

- 실행: Execution Engine이 바이트 코드를 해석하고 실행합니다.

- 종료: 프로그램이 종료되면 JVM은 할당된 메모리를 회수하고 종료됩니다.

## GC가 무엇인지, 필요한 이유는 무엇인지, 동작방식에 대해 설명해주세요.
GC(Garbage Collection)는 자바에서 메모리를 관리하는 프로세스 중 하나입니다. GC는 동적으로 할당된 메모리 중에서 더 이상 사용하지 않는 객체를 찾아 제거하고, 메모리를 회수하는 작업을 수행합니다.

GC가 필요한 이유
- 메모리 누수 방지: 객체를 생성하고 사용하는 동안에 메모리를 할당하게 됩니다. 그러나 객체를 사용하지 않더라도 메모리는 계속해서 사용되고 있어서 시스템의 메모리 사용량이 증가하게 됩니다. GC는 이러한 불필요한 메모리 사용을 감지하여 회수함으로써 메모리 누수를 방지합니다.

- 메모리 할당 최적화: 메모리 할당과 회수는 언제든 일어날 수 있으므로 시스템의 성능에 큰 영향을 미칩니다. GC는 메모리 할당과 회수를 최적화하여 시스템 성능을 개선합니다.

GC의 동작방식
- 객체 추적: GC는 Heap 영역에서 사용 중인 객체들을 추적합니다. 객체가 더 이상 사용되지 않을 때, 즉 참조하는 변수가 없을 때 해당 객체는 가비지(Garbage)로 간주됩니다.

- 가비지 식별: GC는 가비지인 객체들을 식별합니다. 가비지는 Heap 영역에서 다른 객체들과 구분됩니다.

- 가비지 수집: GC는 가비지인 객체들을 수집하여 메모리를 회수합니다. 수집된 객체는 Heap 영역에서 해제됩니다.

- 메모리 정리: 가비지 수집 후, GC는 Heap 영역에서 메모리 조각을 정리하고, 다시 사용 가능한 상태로 만듭니다.

## 컬렉션 프레임워크에 대해서 설명해주세요.
컬렉션 프레임워크(Collection Framework)는 자바에서 데이터를 저장하고 처리하기 위한 인터페이스와 클래스의 모음입니다. 컬렉션 프레임워크는 다양한 자료구조를 제공하며, 이를 활용하여 데이터를 보다 쉽게 다룰 수 있습니다.

컬렉션 프레임워크의 주요 인터페이스
- List 인터페이스: 순서가 있는 데이터 집합을 다루는 인터페이스로, 데이터를 인덱스로 접근할 수 있습니다. ArrayList, LinkedList 등이 List 인터페이스를 구현합니다.

- Set 인터페이스: 순서가 없는 데이터 집합을 다루는 인터페이스로, 중복된 값을 허용하지 않습니다. HashSet, TreeSet 등이 Set 인터페이스를 구현합니다.

- Map 인터페이스: Key-Value 쌍으로 데이터를 저장하고 다루는 인터페이스로, Key를 이용하여 Value를 검색합니다. HashMap, TreeMap 등이 Map 인터페이스를 구현합니다.

컬렉션 프레임워크의 장점

- 자료구조의 추상화: 컬렉션 프레임워크는 다양한 자료구조를 제공하므로, 데이터를 다루는 방식에 따라 적합한 자료구조를 선택하여 사용할 수 있습니다.

- 유연한 데이터 처리: 컬렉션 프레임워크는 다양한 메서드를 제공하므로, 데이터를 보다 쉽게 처리할 수 있습니다. 예를 들어, List 인터페이스는 데이터를 인덱스로 접근할 수 있는 메서드와, 데이터를 검색하는 메서드 등을 제공합니다.

- 표준화된 인터페이스: 컬렉션 프레임워크는 인터페이스와 구현 클래스를 분리하여, 다른 구현 클래스로 쉽게 대체할 수 있도록 구현되어 있습니다. 이로 인해 코드의 재사용성과 유지보수성이 높아집니다.

- 메모리와 성능 최적화: 컬렉션 프레임워크는 내부적으로 데이터를 저장하고 처리하기 위해 알고리즘을 사용합니다. 이 알고리즘은 메모리와 성능을 최적화하는 방향으로 구현되어 있습니다.

## 제네릭에 대해서 설명해주세요.
제네릭(Generic)은 자바에서 데이터 타입을 일반화하는 기능을 제공합니다. 제네릭은 컴파일 시점에 타입 안정성을 보장하므로, 프로그래밍의 실수를 줄이고 유지보수성을 높여줍니다.

## 애노테이션에 대해서 설명해주세요.
애노테이션(Annotation)은 자바에서 소스 코드에 메타데이터를 추가하기 위한 방법입니다. 애노테이션은 컴파일러나 런타임 시점에 소스 코드에 대한 정보를 제공하며, 코드의 문서화와 유지보수를 보다 쉽게 할 수 있습니다. 애노테이션은 컴파일 시점과 런타임 시점에 활용될 수 있으며, 애노테이션을 이용하여 자바 소스 코드의 가독성과 유지보수성을 높일 수 있습니다.

## 오버라이딩과 오버로딩이 무엇이며 어떤 차이가 있을까요?
오버라이딩(Overriding): 상위 클래스에서 정의된 메서드를 하위 클래스에서 재정의하는 것을 말합니다. 오버라이딩된 메서드는 상위 클래스의 메서드와 같은 이름, 매개변수, 반환 타입을 가져야 합니다. 하위 클래스에서 오버라이딩한 메서드는 상위 클래스에서 정의된 동일한 메서드를 가리키며, 이를 런타임 다형성이라고 합니다.

오버로딩(Overloading): 같은 이름의 메서드를 여러 개 정의하는 것을 말합니다. 메서드의 시그니처(매개변수의 개수, 타입, 순서)가 다르면 서로 다른 메서드로 인식합니다. 즉, 같은 이름의 메서드이지만 매개변수의 타입이나 개수 등이 다른 경우, 서로 다른 메서드로 처리됩니다.

오버로딩과 오버라이딩은 메서드의 다형성을 구현하는 데 사용되며, 서로 다른 개념입니다. 오버로딩은 같은 이름의 메서드를 여러 개 정의하는 것을 말하며, 오버라이딩은 상위 클래스의 메서드를 하위 클래스에서 재정의하는 것을 말합니다.

@Override 애노테이션을 써줘야 하는 이유
- 코드 가독성 향상: @Override 애노테이션을 사용하면, 코드의 가독성이 향상됩니다. 이 애노테이션을 사용하면, 오버라이딩된 메서드임을 명시적으로 나타낼 수 있으므로, 코드를 이해하는 데 도움을 줍니다.

- 실수 방지: @Override 애노테이션을 사용하면, 오버라이딩된 메서드를 잘못 구현하는 실수를 방지할 수 있습니다. 만약 오버라이딩된 메서드를 잘못 구현하면, 컴파일러가 오류를 발생시키기 때문입니다.

- 컴파일러 경고 방지: 만약 @Override 애노테이션을 사용하지 않고, 오버라이딩된 메서드를 잘못 구현하면, 컴파일러가 경고를 발생시킵니다. 이러한 경고는 코드의 오류를 발견하는 데 도움이 되지만, @Override 애노테이션을 사용하면, 이러한 경고를 방지할 수 있습니다.

## 인터페이스와 추상클래스의 차이점에 대해 설명해주세요.
인터페이스와 추상클래스는 자바에서 추상화를 구현하는 두 가지 방법입니다. 여기서 추상화는 구현 세부 정보를 숨기고 추상적인 개념만을 다루는 것을 말합니다.
- 인터페이스(Interface): 인터페이스는 추상적인 개념을 정의하는데 사용됩니다. 인터페이스는 메서드의 시그니처만을 정의하고, 메서드의 구현은 인터페이스를 구현하는 클래스에서 수행합니다. 즉, 인터페이스는 일종의 계약(contract)으로, 해당 인터페이스를 구현하는 클래스는 정의된 메서드를 반드시 구현해야 합니다.
- 추상클래스(Abstract Class): 추상클래스는 인터페이스와 비슷하게 추상화를 구현하는데 사용됩니다. 추상클래스는 일부 메서드를 구현할 수 있으며, 구현되지 않은 메서드를 추상 메서드로 정의할 수 있습니다. 추상 메서드는 인터페이스와 마찬가지로 구현되지 않은 메서드를 정의하는데 사용됩니다.

인터페이스와 추상클래스의 차이점
- 메서드 구현 여부: 인터페이스는 메서드의 구현을 하지 않으며, 추상클래스는 메서드의 일부를 구현할 수 있습니다.

- 다중 상속 가능 여부: 자바에서는 클래스의 다중 상속이 불가능합니다. 하지만, 인터페이스는 다중 상속이 가능합니다. 즉, 여러 개의 인터페이스를 구현할 수 있습니다.

## 클래스는 무엇이고 객체는 무엇인가요?
클래스(Class)는 자바에서 객체(Object)를 생성하기 위한 설계도 또는 틀을 말합니다. 클래스는 객체의 속성을 정의하고, 객체가 수행할 수 있는 행위를 정의하는 메서드를 포함합니다. 객체는 이러한 클래스를 바탕으로 생성됩니다.

객체(Object)는 클래스(Class)를 기반으로 생성된 실체(Instance)를 말합니다. 즉, 클래스는 객체를 생성하기 위한 설계도일 뿐, 객체는 이 설계도를 바탕으로 생성된 실체입니다. 객체는 클래스에서 정의된 속성과 메서드를 포함하며, 이를 이용하여 프로그램에서 데이터를 처리하고 조작합니다.

예를 들어, 자동차 클래스를 생성한다면, 이 클래스는 자동차 객체를 생성하기 위한 설계도가 됩니다. 자동차 객체는 클래스에서 정의된 속성(차종, 모델, 색상 등)과 메서드(주행, 정비, 가속 등)를 포함하며, 이를 이용하여 자동차를 운전하고 관리할 수 있습니다.

자바에서는 클래스를 이용하여 객체를 생성하며, 객체는 프로그램에서 데이터를 처리하고 조작하는데 사용됩니다. 따라서, 객체는 클래스의 실체로서 중요한 역할을 합니다.

## 정적(static)이란 무엇인가요?
Java에서 static 키워드를 사용하면, 해당 클래스의 정적 변수와 정적 메서드는 프로그램이 실행될 때 메모리에 딱 한 번만 할당되며, 객체 생성 없이 클래스 이름으로 접근할 수 있습니다.
정적 변수와 정적 메서드는 메모리 상에 클래스 정보(Method Area)에 저장됩니다. 클래스가 로드될 때 클래스 정보가 메모리에 할당되며, 해당 클래스의 정적 변수와 정적 메서드도 함께 할당됩니다. 이후 프로그램이 실행되는 동안, 해당 클래스의 정적 변수와 정적 메서드는 프로그램 전체에서 공유되며, 객체 생성 없이도 클래스 이름으로 접근할 수 있습니다.

그러나, GC의 관리 영역 밖에 존재하기 때문에 프로그램 종료시까지 메모리가 할당된 채로 존재합니다. 너무 남발하게 되면 시스템 성능에 악영향을 줄 수 있습니다.

- 정적 변수(Static variable): 클래스 변수라고도 하며, 클래스와 관련된 공통된 속성을 가지고 있는 변수입니다. 정적 변수는 객체 생성 없이도 클래스 이름으로 접근할 수 있습니다. 또한, 정적 변수는 프로그램이 실행되는 동안 메모리에서 유지되며, 모든 객체에서 공유됩니다.

- 정적 메서드(Static method): 클래스와 관련된 메서드로, 객체 생성 없이도 클래스 이름으로 접근할 수 있습니다. 정적 메서드는 클래스의 상태에 의존하지 않는 메서드로, 객체를 생성하지 않고도 호출할 수 있습니다.

## 자바의 원시타입들은 무엇이 있으며 각각 몇 바이트를 차지하나요?
자바에서 사용되는 원시 데이터 타입(Primitive data types) 종류
- byte : 1 byte, -128 ~ 127 범위의 부호 있는 정수를 저장할 수 있습니다.
- short : 2 bytes, -32,768 ~ 32,767 범위의 부호 있는 정수를 저장할 수 있습니다.
- int : 4 bytes, -2,147,483,648 ~ 2,147,483,647 범위의 부호 있는 정수를 저장할 수 있습니다.
- long : 8 bytes, -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 범위의 부호 있는 정수를 저장할 수 있습니다.
- float : 4 bytes, 소수점 이하 7자리까지 정확도를 가진 부동 소수점 수를 저장할 수 있습니다.
- double : 8 bytes, 소수점 이하 15자리까지 정확도를 가진 부동 소수점 수를 저장할 수 있습니다.
- char : 2 bytes, 유니코드 문자 하나를 저장할 수 있습니다.
- boolean : 1 byte (1 bit로도 가능하지만, 실제로는 1 byte로 할당), true 또는 false 값을 저장할 수 있습니다.

## 접근 제어자의 종류와 이에 대해 설명해주세요.
- public: 어떤 패키지에서도 접근이 가능합니다. public으로 선언된 멤버는 다른 패키지에서도 접근할 수 있습니다.

- protected: 같은 패키지에서는 물론 자식 클래스에서도 접근이 가능합니다. protected로 선언된 멤버는 같은 패키지의 다른 클래스나 자식 클래스에서 접근할 수 있습니다.

- default (package-private): 접근 제어자를 지정하지 않은 경우, 같은 패키지에서만 접근이 가능합니다. default로 선언된 멤버는 같은 패키지의 다른 클래스에서는 접근할 수 있지만, 다른 패키지에서는 접근할 수 없습니다.

- private: 같은 클래스에서만 접근이 가능합니다. private으로 선언된 멤버는 해당 클래스 내부에서만 접근할 수 있습니다.

## 객체지향에 대해서 설명해주세요.

## SOLID(객체지향 5대원칙)에 대해서 설명해주세요

## 동일성(identity)와 동등성(equality)에 대해 설명해주세요. (equals(), ==)

## 원시타입과 참조타입의 차이에 대해 설명해주세요.

## String, StringBuilder, StringBuffer 각각의 차이에 대해 설명해주세요.

## Checked Exception과 Unchecked Exception에 대해 설명해주세요. 스프링 트랜잭션 추상화에서 rollback 대상은 무엇일까요?

## Java8에서 추가된 기능에 대해서 설명해주세요.

## try-with-resource에 대해서 설명해주세요.

## 강한 결합과 느슨한 결합이 무엇인지 설명해주세요.

## 직렬화와 역직렬화에 대해서 설명해주세요.

## 자바의 동시성 이슈(공유자원 접근)에 대해 설명해주세요.

## Mutable 객체와 Immutable 객체의 차이점에 대해 설명해주세요.

## 자바에서 null을 안전하게 다루는 방법에 대해 설명해주세요.

## Wrapper class란 무엇인가요?

# 자료구조

## List와 Set의 차이에 대해서 설명해주세요.

## Hash Function, HashTable에 대해서 설명해주세요.

## Stack, Queue에 대해서 설명해주세요.

## 배열과 링크드 리스트의 차이를 설명해주세요.

## HashMap vs LinkedHashMap 차이와 장단점은?

## 시간복잡도와 공간복잡도는?
