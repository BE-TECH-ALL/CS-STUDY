# 애노테이션에 대해서 설명해주세요.
애노테이션은 인터페이스를 기반으로 한 문법으로 주석처럼 코드에 달아 클래스에 특별한 의미를 부여하거나 기능을 주입할 수 있습니다. built-in annotation은 상속받아서 메소드를 오버라이드 할 때 나타나는 @Override 애노테이션이 그 대표적인 예입니다.

메타 애너테이션은 애노테이션을 선언할 때 사용하는 애노테이션입니다.

@Retention: 애노테이션 유지 범위를 지정합니다. (소스, 클래스, 런타임)
@Inherit: 애노테이션을 하위 클래스까지 전달여부를 지정합니다. 이 애노테이션이 있으면 하위 클래스까지 상속이 가능합니다.
@Target: 해당 애노테이션을 어디에 사용할 지 결정합니다. (타입, 필드, 메서드, 파라미터, 생성자, 로컬변수, 애노테이션 타입)

# 오버라이딩과 오버로딩이 무엇이며 어떤 차이가 있을까요?
오버라이딩은 상위 클래스의 메소드를 재정의 하는 것을 의미합니다. 또, 런타임 다형성이기도 합니다.

오버로딩은 같은 클래스 내에서 동일한 메소드 이름을 가지지만, 매개변수의 타입, 개수가 다르게 구현할 수 있는 것을 의미하며 컴파일 타임 다형성이기도 합니다. 따라서 오버라이딩 될 수 있습니다.

# 클래스는 무엇이고 객체는 무엇인가요?
클래스는 객체지향 프로그래밍의 핵심 개념 중 하나로, 객체를 생성하기 위한 템플릿이며, 객체의 상태를 나타내는 필드와 객체의 행동을 나타내는 메소드로 구성되어있습니다.
객체는 클래스에서 정의한 것을 토대로 메모리에 할당된 실체를 말하며, 수명주기동안 상태(필드)와 동작(메서드)를 가지고 다른 객체와 상호작용할 수 있습니다.

# 인터페이스와 추상클래스의 차이점에 대해 설명해주세요.
추상클래스는 객체의 추상적인 상위 개념으로 공통된 개념을 표현할 때 사용합니다. 단일 상속만 가능합니다. 추상클래스를 상속하는 집합간에는 연관관계가 있습니다.

인터페이스는 구현 객체가 같은 동작을 한다는 것을 보장하기 위해 사용합니다. 다중 상속이 가능합니다. 인터페이스를 구현하는 집합간에는 관계가 없을 수 있습니다.

# 컬렉션 프레임워크에 대해서 설명해주세요.컬렉션 프레임워크에 대해서 설명해주세요.
Java Collection은 널리 알려져 있는 자료구조를 바탕으로 객체, 데이터들을 효율적으로 관리 할 수 있는 자료구조들이 있는 라이브러리를 컬렉션 프레임워크라고 합니다.

List, Set은 Collection 인터페이스을 상속받지만, Map 인터페이스는 구조상의 차이라 별도로 정의합니다.

# 객체지향에 대해서 설명해주세요.
객체지향을 정의하면, 의존성 관리입니다.

객체지향으로 의존성을 관리함으로써 변경 영향을 최소화하고 독립적인 배포가 가능해지며 독립적인 개발이 가능해집니다. 따라서 객체지향에서 가장 중요한 것은 DIP(Dependency Inversion Principle)를 통한 고수준 정책(High Level Policy)와 저수준 구현 세부사항(Low Level Details)의 분리라고 할 수 있습니다.

# Java의 main 메서드가 static인 이유를 설명해주세요.
일반적으로 static으로 선언될 경우 컴파일 시에 메모리에 올라와 있기 때문에 객체 생성을 하지 않고 사용할 수 있지만
static으로 선언되지 않을 경우에 런타임 시에 객체 생성 후 사용되어야 합니다.
main 메서드는 컴파일 시에 이미 메모리에 올라와있어야 하기 때문에 static으로 선언되어야 합니다.
